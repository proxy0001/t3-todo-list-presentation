<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>T3-todo-list Presentation</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-auto-animate>
					<textarea data-template>
						
						## t3-todo-list
						- [Online Demo](https://t3-todo-list.vercel.app/)
						- [Source Code](https://github.com/proxy0001/todo-list)
						---

						## ç›®éŒ„
						1. [Using Tools](#/2)
						2. [DB Schema & Migrations](#/4)
						3. [Backend APIs](#/4)
						4. [Frontend](#/11)
						5. [Testing](#/18)
						6. [Frontend Refactor](#/24)
						7. [Presentation Tool](#/31)


						---
						## Tools
						- [create-t3-app](https://create.t3.gg/)
							- [Next.js](https://nextjs.org/)
							- [tRPC](https://trpc.io/)
							- [Prisma](https://www.prisma.io/)
							- [Tailwind CSS](https://tailwindcss.com/)
							- [NextAuth.js](https://next-auth.js.org/)
						- [React Spectrum](https://react-spectrum.adobe.com/react-spectrum/index.html)
						---

						## Tools
						- [create-t3-app](https://create.t3.gg/): Cli
							- [Next.js](https://nextjs.org/): React Framework
							- [tRPC](https://trpc.io/): End-to-End Typesafe
							- [Prisma](https://www.prisma.io/): ORM
							- [Tailwind CSS](https://tailwindcss.com/): Utility CSS Framework
							- [NextAuth.js](https://next-auth.js.org/): Authentication for Next.js
						- [React Spectrum](https://react-spectrum.adobe.com/react-spectrum/index.html): UI Library
						---

						## Base Types
						ä½¿ç”¨ [Zod](https://zod.dev/) åšå‹åˆ¥å®šç¾©ï¼Œå› ç‚º [tRPC](https://trpc.io/) éœ€è¦ä½¿ç”¨åˆ° ZodTypeï¼Œåœ¨ Runtime æ™‚é€²è¡Œå‹åˆ¥é©—è­‰ã€‚
						```typescript
						// src/types/task.ts
						export const task = z.object({
							id: z.number(),
							userId,
							title: z.string(),
							isFinished: z.boolean().optional(),
							isArchived: z.boolean().optional(),
							createdAt: z.date().optional(),
							updatedAt: z.date().optional(),
						})
						export type Task = z.infer<typeof task>
						```
						---

						## DB Schema
						ä½¿ç”¨ [Prisma](https://www.prisma.io/) çš„èªæ³•: Prisma Schema Language (PSL) å®šç¾© Schemaã€‚
						```primsa
						// prisma/schema.prisma
						model Task {
							id         Int       @id @default(autoincrement())
							userId     String
							createdAt  DateTime  @default(now())
							updatedAt  DateTime  @updatedAt
							title      String    @db.Text
							isFinished Boolean   @default(false)
							isArchived Boolean   @default(false)
							user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
						}

						```

						---
						## DB Migrations
						æ›´æ–° Schema ä¹‹å¾Œï¼Œä½¿ç”¨ Cli å·¥å…·è‡ªå‹•ç”¢ç”Ÿ Migrationsã€‚
						```
						npx prisma migrate dev --name init
						```
						â†“
						```
						prisma/
						â””â”€ migrations/
							â””â”€ 20230117124118_init/
								â””â”€ migration.sql
						```

						---
						## Backend APIs
						ä¸»è¦åšçš„äº‹æƒ…å°±æ˜¯å®šç¾© [Procedure](https://trpc.io/docs/procedures)ï¼Œé¡ä¼¼æ–¼ REST-endpointã€‚
						```
						src/
						â””â”€ server/
							â””â”€ api/
								â””â”€ routers/ 
									â””â”€ task.ts // å¯¦ä½œçš„åœ°æ–¹
								â””â”€ root.ts // é›†æˆæ‰€æœ‰ routers
						â””â”€ pages/
							â””â”€ api/
								â””â”€ trpc/
									â””â”€ [trpc].ts // ç”¢ç”Ÿ tRPC çš„ APIs
						```
						---
						## Backend APIs
						[tRPC](https://trpc.io/) ç”¢ç”Ÿçš„ API è·Ÿ Open API çš„å®šç¾©ä¸åŒï¼Œéœ€è¦æ­é… [trpc-openapi](https://github.com/jlalmes/trpc-openapi) é€™å€‹æ’ä»¶é€²è¡Œè½‰æ›ï¼Œé€™éƒ¨åˆ†éœ€è¦è‡ªè¡Œé…ç½®ã€‚å‰å°ä»‹é¢ä½¿ç”¨ [Swagger-UI](https://github.com/swagger-api/swagger-ui)ã€‚
						```
						src/
						â””â”€ server/
							â””â”€ openapi.ts // ç”¢ç”Ÿ Open API Document JSON
						â””â”€ pages/
							â””â”€ api/
								â””â”€ [trpc].ts // ç”¢ç”Ÿ Open APIs (é€™éš»åç¨±æ‡‰è©²è¦æ”¹)
								â””â”€ openapi.json.ts // ç²å– Open API Document JSON çš„ API
							â””â”€ api-doc.tsx // API å‰å°ä»‹é¢ (Swagger-UI)
						```

						---
						## Backend APIs

						ç”¨ tRPC å¯¦ä½œ Procedureã€‚
						```javascript
						// src/server/api/routers/task.ts
						export const taskRouter = createTRPCRouter({
							create: protectedProcedure
								// å®šç¾© meta è®“ trpc-openapi ç”¨ä¾†ç”¢ç”Ÿ Open API Document
								.meta({ openapi: { method: 'POST', path: '/tasks', tags: ['task'], summary: 'Create a task.' }})
								// ç”¨ ZodType åšå‹åˆ¥é©—è­‰
								.input(taskSchema.noHeadTask)
								.output(taskSchema.task)
								// ä¸»è¦æœ‰ query è·Ÿ mutation å…©ç¨®ç¨‹åºï¼Œä½†å·®åˆ¥åªæœ‰èªæ„ã€‚
								.mutation(async ({ ctx, input }) => {
									// ç”¨ Prima Client å°è³‡æ–™åº«é€²è¡Œæ“ä½œ
									return await ctx.prisma.task.create({
										data: input
									})
								}),
						})
						```

						---
						## Backend APIs

						ç”¢ç”Ÿçš„ API é•·å¾—åƒé€™æ¨£ï¼š
						```
						// tRPC ç”¢ç”Ÿçš„ API
						http://localhost:3000/api/trpc/task.todoList?input={"json":{"userId":"cle06jmqd0000dwbus629b1ru"}}
						
						// è½‰æ›æˆ Open API
						http://localhost:3000/api/todoList?userId=cle06jmqd0000dwbus629b1ru
						```

						---
						## Frontend
						æª”æ¡ˆçµæ§‹
						```
						src/
						â””â”€ components/
							â””â”€ EditTask.tsx // ç·¨è¼¯ Task çš„å°çµ„ä»¶
							â””â”€ TaskManager.tsx // ç®¡ç† Task çš„å¤§çµ„ä»¶ï¼Œéœ€æ”¾å…¥å°æ‡‰çš„ Model ä½¿ç”¨
						â””â”€ hooks/
							â””â”€ useDemoTaskModel.ts // For Demo
							â””â”€ usePrismaTaskModel.ts // ç®¡ç†è³‡æ–™çš„ Model
						â””â”€ pages/
							â””â”€ index.jsx // é¦–é 
						```

						---
						## Frontend Model Type
						å®šç¾© Model çš„ Type
						```javascript
						// src/types/task.ts
						export const taskModel = z.object({
							userId,
							// æä¾› 3 ç¨®ä¸åŒä»»å‹™ç‹€æ…‹çš„ Lists
							todoList: taskList,
							finishList: taskList,
							archiveList: taskList,
							// æ›´æ–° Task ç‹€æ…‹çš„ Methods
							createTask: z.function().args(task).returns(z.void()),
							pushTask: z.function().args(task).returns(z.void()),
							finishTask: z.function().args(task).returns(z.void()),
							unfinishTask: z.function().args(task).returns(z.void()),
							archiveTask: z.function().args(task).returns(z.void()),
							unarchiveTask: z.function().args(task).returns(z.void()),
							deleteTask: z.function().args(task).returns(z.void()),
						})
						export type TaskModel = z.infer<typeof taskModel>
						```
						
						---
						## Frontend Index
						æ ¹æ“šæ˜¯å¦æœ‰ç™»å…¥ï¼Œé¸æ“‡è¦ä½¿ç”¨çš„ Modelã€‚
						```tsx
						// src/pages/index.tsx
						const Home: NextPage = () => {
							const { data: sessionData, status: sessionStatus } = useSession()
							const demoModel = useDemoTaskModel({ userId })
							const prismaModel = usePrismaTaskModel({ userId })
							const model = sessionData ? prismaModel : demoModel
							return (
								<TaskManager model={model} />
							)
						}
						```

						---
						## Model For Demo
						```tsx
						// src/hooks/useDemoTaskModel.tsx
						export const useDemoTaskModel: UseTaskModel = ({ userId = '' } = {}) => {
							const [taskList, setTaskList] = useState(defaultTaskList)
							const [todoList, setTodoList] = useState(todosFilter(taskList))
							const [finishList, setFinishList] = useState(finishesFilter(taskList))
							const [archiveList, setArchiveList] = useState(archivesFilter(taskList))
						
							useLayoutEffect(() => {
								setTodoList(todosFilter(sorted))
								setFinishList(finishesFilter(sorted))
								setArchiveList(archivesFilter(sorted))
							}, [taskList])
						
							// å¯¦ä½œæ›´æ–° taskList çš„å„å€‹æ–¹æ³•
							const createTask: TaskModel['createTask'] = task => {}
							const pushTask: TaskModel['pushTask'] = (updatedTask: Task): void => {}
							const finishTask: TaskModel['finishTask'] = task => {}
							const unfinishTask: TaskModel['unfinishTask'] = task => {}
							const archiveTask: TaskModel['archiveTask'] = task => {}
							const unarchiveTask: TaskModel['unarchiveTask'] = task => {}
							const deleteTask: TaskModel['deleteTask'] = task => {}
						
							return {
								userId,
								todoList,
								finishList,
								archiveList,
								createTask,
								pushTask,
								finishTask,
								unfinishTask,
								archiveTask,
								unarchiveTask,
								deleteTask,
							}
						}
						```

						---
						## Model For Real
						ä½¿ç”¨ [tRPC Client](https://trpc.io/docs/client) æ“ä½œå¾Œç«¯ APIï¼Œå…§å»ºä½¿ç”¨ [react-query](https://trpc.io/docs/react-query)ã€‚
						```tsx
						// src/hooks/usePrismaTaskModel.tsx
						export const usePrismaTaskModel: UseTaskModel = ({ userId = '' } = {}) => {
							// create-t3-app å°‡å¹¾å€‹å·¥å…·æ•´åˆèµ·ä¾†ï¼Œæ–¹ä¾¿èª¿ç”¨
							const utils = api.useContext()
							const [todoList, setTodoList] = useState<TaskList>([])
							// ç²å–è³‡æ–™
							const { data: newTodoList } = api.task.todoList.useQuery({ userId })
							// æ›´æ–°é¡¯ç¤º
							useLayoutEffect(() => {
								setTodoList(newTodoList || [])
							}, [newTodoList])
							
							const createTaskMutation = api.task.create.useMutation({
								async onMutate (newTask) {
									// å¯¦ä½œ Optimistic Update
									await utils.task.todoList.cancel();
									const prevData = utils.task.todoList.getData();
									const tmpNewTaskForDisplay = { ...newTask, id: -2 }
									utils.task.todoList.setData({ userId }, (old) => old ? [tmpNewTaskForDisplay, ...old] : []);
									return { prevData };
								},
								async onSettled () {
									// é‡æ–°ç²å–è³‡æ–™ï¼Œç¢ºä¿å‰å¾Œç«¯åŒæ­¥
									await utils.task.todoList.invalidate();
								}
							})

							const createTask: TaskModel['createTask'] = task => {
								const { id, ...noHeadTask } = task
								createTaskMutation.mutate(noHeadTask, {
									onSuccess: (data, variables, context) => {
										// console.log(`created`, data)
									},
									onError: (error, variables, context) => {
										console.log(`An error happened! ${error.message}`)
									},
								})
							}
						}
						```

						---
						## Model For Real
						Task ç‹€æ…‹æ›´æ–°æœƒæœ‰å…©ç¨®æƒ…æ³ï¼š
						1. ç•™åœ¨åŒä¸€å€‹ Listï¼š ä¾‹å¦‚æ›´æ”¹æ¨™é¡Œ
						2. ç§»å‹•åˆ°å¦ä¸€å€‹ Listï¼š ä¾‹å¦‚å°‡ç‹€æ…‹æ”¹æˆå·²å®Œæˆ
						
						```tsx
						// src/hooks/usePrismaTaskModel.tsx
						export const usePrismaTaskModel: UseTaskModel = ({ userId = '' } = {}) => {
							const utils = api.useContext()
							const pushTaskMutation = api.task.push.useMutation({
								async onMutate (newTask) {
									// æ ¹æ“š Task çš„ç‹€æ…‹è®ŠåŒ–ï¼Œåæ¨æœƒå¾å“ªå€‹ List ç§»å‹•è‡³ å“ªå€‹ List
									const { fromWhich, toWhich } = fromWhichToWich(oldTask, newTask)
									if (fromWhich === toWhich) {
										// æ›´æ–°å¾Œï¼Œéƒ½é‚„æ˜¯åœ¨åŒä¸€å€‹ List è£¡é¢
										// å°è©² List é€²è¡Œæ¨‚è§€æ›´æ–°
									} else {
										// æ›´æ–°å¾Œï¼Œæœƒå¾ A List ç§»å‹•åˆ° B List
										// å° A, B å…©å€‹ List é€²è¡Œæ¨‚è§€æ›´æ–°
									}
								},
								async onSettled (newTask) {
									// é‡æ–°ç²å–è³‡æ–™ï¼Œç¢ºä¿å‰å¾Œç«¯åŒæ­¥
									if (fromWhich === toWhich) {
										// å°è©² List é€²è¡ŒåŒæ­¥
									} else {
										// å°å…©å€‹ List é€²è¡ŒåŒæ­¥
									}
								}
							})
	
							const pushTask: TaskModel['pushTask'] = (updatedTask: Task): void => {
								pushTaskMutation.mutate(updatedTask)
							}
						
						}
						```
						
						---
						## TaskManager Component
						ä¸»è¦å°±æ˜¯ç¶å®šäº’å‹•äº‹ä»¶åŸ·è¡Œå°æ‡‰çš„ Model Functionï¼Œä»¥åŠè‡ªè¡Œç®¡ç†ç·¨è¼¯ç‹€æ…‹ï¼ŒUI å»ºæ§‹ä½¿ç”¨ [React Spectrum](https://react-spectrum.adobe.com/react-spectrum/index.html) ã€‚
						```tsx
						// src/components/TaskManager.tsx
						export const TaskManager = ({ model }: TaskManagerProps) => {
							// use Model
							const { todoList, finishList, archiveList, pushTask, finishTask, unfinishTask, archiveTask, unarchiveTask, deleteTask } = model
							const [editingTask, setEditingTask] = useState<Task | null>(NULL_EDITING_TASK)
							
							// å¤šåŒ…ä¸€å±¤å¤ªç„¡è¬‚ï¼Œé‡æ§‹æ™‚æ‹¿æ‰äº†ï¼Œé‚„æ˜¯ç›´æ¥å®šç¾© onCancel çš„å‡½å¼å°±å¥½
							const commands: Commands = {
								CANCEL: () => setEditingTask(NULL_EDITING_TASK),
								CREATE: (task = NEW_EDITING_TASK) => setEditingTask(task),
								SUBMIT: task => {
									task && pushTask(task)
									setEditingTask(NULL_EDITING_TASK)
								},
								UPDATE: task => setEditingTask({ ...task } as Task),
								FINISH: task => finishTask(task),
								UNFINISH: task => unfinishTask(task),
								ARCHIVE: task => archiveTask(task),
								UNARCHIVE: task => unarchiveTask(task),
								DELETE: task => deleteTask(task),
							}
						
							const onCheckboxChange = (task: Task): SpectrumCheckboxProps['onChange'] => {
								return isSelected => isSelected ?
									commands[Actions.Finish](task) :
									commands[Actions.Unfinish](task)
							}
						
							return (
								...
								{
									// æ–°å¢çµ„ä»¶æ™‚ï¼Œé¡¯ç¤º EditTask Component
									editingTask && isNewEditing(editingTask) ?
									<EditTask task={editingTask} onSubmit={commands[Actions.Submit]} onCansel={commands[Actions.Cancel]} /> :
									null
								}
								
								{todoList.map(task => (
									// ç·¨è¼¯çµ„ä»¶æ™‚ï¼Œæ”¹é¡¯ç¤º EditTask Component
									editingTask && isEditing(editingTask, task) ?
									<EditTask key={`editing-${task.id}`} task={editingTask} onSubmit={commands[Actions.Submit]} onCansel={commands[Actions.Cancel]} /> :
									// ä¸€èˆ¬é¡¯ç¤ºé …ç›®
									<Flex key={task.id} justifyContent="space-between">
										<Checkbox marginEnd="size-200" flexGrow={1} isSelected={task.isFinished} onChange={onCheckboxChange(task)}> {task.title} </Checkbox>
										<ButtonGroup>
											<ActionButton isQuiet onPress={e => commands[Actions.Update](task)} aria-label="Edit task"><EditIcon /></ActionButton>
											<ActionButton isQuiet onPress={e => commands[Actions.Archive](task)} aria-label="Archive task"><ArchiveIcon /></ActionButton>
											<ActionButton isQuiet onPress={e => commands[Actions.Delete](task)} aria-label="Delete task"><DeleteIcon /></ActionButton>
										</ButtonGroup>
									</Flex>
								))}
								...
							)
						}
						```

						---
						## Test
						ä½¿ç”¨ Jestã€‚å‰ç«¯é‡å° hooks æ¸¬è©¦ï¼Œå¾Œç«¯é‡å° APIs æ¸¬è©¦ï¼Œåˆ†æˆ unit test è·Ÿ integration testã€‚
						
						```
						src/
						â””â”€ hooks/
							â””â”€ useDemoTaskModel.unit.test.ts
							â””â”€ usePrismaTaskModel.integration.test.ts
						â””â”€ server/
							â””â”€ api/
								â””â”€ routers/
									â””â”€ task.unit.test.ts
									â””â”€ task.integration.test.ts
						â””â”€ utils/
							â””â”€ testUtils.ts // for æ¸¬è©¦ç”¨çš„ä¸€äº›å…±ç”¨æ–¹æ³•
							â””â”€ testWrapper.tsx // for å‰ç«¯æ¸¬è©¦æ™‚ï¼Œéœ€è¦äº‹å…ˆæº–å‚™ tRPC Providers
						â””â”€ jest.config.ts // ç’°å¢ƒè¨­å®š
						â””â”€ docker-compose.yaml // èµ·æ¸¬è©¦è³‡æ–™åº«
						```

						---
						## Test Environment
						ä½¿ç”¨ projects å°‡å‰å¾Œç«¯çš„æ¸¬è©¦ç’°å¢ƒåˆ†é–‹

						```javascript
						// jest.config.ts
						const config: Config = {
							coverageProvider: "v8",
							// å°‡å‰ç«¯è·Ÿå¾Œç«¯çš„æ¸¬è©¦ç’°å¢ƒè¨­å®šåˆ†é–‹
							// å¦å¤–å°‡ unit test è·Ÿ integration test åˆ†é–‹
							projects: [
								// å¾Œç«¯æ¸¬è©¦ç’°å¢ƒ
								{
									...commonConfig,
									displayName: 'server:unit',
									rootDir: "<rootDir>/src/server",
									testEnvironment: "node",
									testMatch: [ "**/__tests__/**/*.unit.[jt]s?(x)", "**/?(*.unit.)+(spec|test).[jt]s?(x)" ]
								},
								{
									...commonConfig,
									displayName: 'server:integration',
									rootDir: "<rootDir>/src/server",
									testEnvironment: "node",
									testMatch: [ "**/__tests__/**/*.integration.[jt]s?(x)", "**/?(*.integration.)+(spec|test).[jt]s?(x)" ]
								},
								// å‰ç«¯æ¸¬è©¦ç’°å¢ƒ
								{
									...commonConfig,
									displayName: 'client',
									rootDir: "<rootDir>",
									testPathIgnorePatterns: ["<rootDir>/node_modules/", "<rootDir>/src/server/"],
									setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],
									moduleDirectories: ["node_modules", "<rootDir>/"],
									// ä½¿ç”¨ jsdom æ¨¡æ“¬ç€è¦½å™¨ç’°å¢ƒ
									testEnvironment: "jest-environment-jsdom",
									transform: {
										'^.+\\.(mjs|js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'], "plugins": ["@babel/plugin-proposal-private-methods"] }],
									},
									// ä¸è¦ ignore node_modules (default æ˜¯æœƒ)
									transformIgnorePatterns: [],
								}
							],
						}
						```
						
						---
						### Backend Unit Test
						å–®ç´”æ¸¬è©¦ APIï¼Œå° Prisma é€²è¡Œ Mockï¼Œé¿å…ä¾è³´æ–¼è³‡æ–™åº«æ“ä½œã€‚
						```javascript
						// src/utils/testUtils.ts
						export const setupCallerWithMockPrisma: SetupCallerWithMockPrisma = mockPrismaResponse => {
							// å»ºç«‹ mock Prisma
							const mockPrisma = mockDeep<PrismaClient>()
							const mockSession = createMockSession()
							const mockCtx = {
								session: mockSession,
								prisma: mockPrismaResponse(mockPrisma)
							}
							return {
								// å»ºç«‹ api caller (ä½¿ç”¨ mock çš„ prisma)
								caller: appRouter.createCaller(mockCtx),
								...mockCtx,
							}
						}

						// src/server/api/routers/task.unit.test.ts
						describe('test task APIs with mock Prisma', () => {
							it('should return all todos of the user', async () => {
								type Input = inferProcedureInput<AppRouter['task']['todoList']>
								const input: Input = {
									userId: mockData.userId
								}
								// è¨­å®š mock primsa è¦å›å‚³çš„å…§å®¹
								const mockOutput = mockData.todoList
								const { caller, prisma } = setupCallerWithMockPrisma(mockPrisma => {
									mockPrisma.task.findMany.mockResolvedValue(mockOutput)
									return mockPrisma
								})
						
								const result = await caller.task.todoList(input)
								expect(prisma.task.findMany).toHaveBeenCalled()
								expect(result).toHaveLength(mockOutput.length)
								expect(result).toStrictEqual(mockOutput)
							})
						})
						```

						---
						### Backend Integration Test
						ç”¨ docker èµ·æ¸¬è©¦è³‡æ–™åº«ï¼Œå° APIs é€²è¡Œæ•´åˆæ¸¬è©¦ã€‚
						```javascript
						// src/server/api/routers/task.integration.test.ts
						// æº–å‚™å‡è³‡æ–™
						beforeAll(async () => {
							await prisma.user.create({
								data: mockData.userData
							})
							await prisma.task.createMany({
								data: mockData.taskData
							})
						})
						// æ¸…ç©ºå‡è³‡æ–™
						afterAll(async () => {
							await prisma.$transaction([
								prisma.task.deleteMany(),
								prisma.user.deleteMany(),
							])
						
							await prisma.$disconnect()
						})
						
						describe('test task APIs with real db', () => {
							const caller = setupCaller()
						
							it('should return all todos of the user', async () => {
								type Input = inferProcedureInput<AppRouter['task']['todoList']>
								const input: Input = {
									userId: mockData.userId
								}
								const result = await caller.task.todoList(input)
								expect(result).toHaveLength(mockData.todoList.length)
								expect(result).toMatchObject(mockData.todoList)
							})
						})
						```

						---
						### Frontend Unit Test
						éœ€è¦ä½¿ç”¨æ–¹ä¾¿æ¸¬è©¦ React Hooks çš„ç›¸é—œå¥—ä»¶ã€‚

						```javascript
						// src/hooks/useDemoTaskModel.unit.test.ts
						import { renderHook, act } from '@testing-library/react'

						const setup = () => renderHook(() => useDemoTaskModel({ userId: 'tester'}))
							
						describe('create task', () => {
							it('should add a new task in todo list', () => {
								const { result } = setup()
								const newTask = { id: 0, title: 'create task', userId: result.current.userId }
								
								act(() => {
									result.current.createTask(newTask)
								})

								expect(result.current.todoList.length).toBe(2)
								expect(result.current.todoList[0]).toMatchObject({ ...newTask, id: 4 })
							})
						})
						```

						---
						### Frontend Integration Test
						ç‚ºäº†è®“ tRPC Client èƒ½å¤ é †åˆ©é‹è¡Œï¼Œéœ€è¦äº‹å…ˆæº–å‚™ä¸€äº› Providersï¼Œå› æ­¤æœƒå¼•å…¥è¨±å¤š Node Base çš„å¥—ä»¶ï¼Œé€™äº›å¾ˆå¤šéƒ½ä¸ç›¸å®¹æ–¼ jsdom çš„æ¸¬è©¦ç’°å¢ƒï¼Œä¾‹å¦‚ ESM çš„å¥—ä»¶éœ€è¦å¦å¤–è¨­å®šè½‰æ›ã€‚

						```javascript
						// src/hooks/usePrismaTaskModel.integration.test.ts
						
						// ä¸»è¦å° NextAuth çš„ getServerSession é€²è¡Œ Mock
						mockNextAuth()
						// æº–å‚™è³‡æ–™åº«è£¡çš„å‡è³‡æ–™
						beforeAll(async () => {
							await prisma.user.create({
								data: mockData.userData
							})
							await prisma.task.createMany({
								data: mockData.taskData
							})
						})
						// æ¸…ç©ºå‡è³‡æ–™
						afterAll(async () => {
							await prisma.$transaction([
								prisma.task.deleteMany(),
								prisma.user.deleteMany(),
							])
						
							await prisma.$disconnect()
						})
						
						// renderHook æ™‚ï¼Œå‚³å…¥é¡å¤–çš„ wrapperï¼Œæä¾›ä¸€äº› tRPC é‹è¡Œå¿…è¦çš„ Providersã€‚
						const setup = () => renderHook(() => usePrismaTaskModel({ userId: mockData.userId}), {
							wrapper: hookWrapper(mockData.userData),
						})
					
						describe('create task', () => {
							it('should add a new task in todo list', async () => {
								const { result } = setup()
								const originLength = result.current.todoList.length
				
								result.current.createTask(mockData.newTodoTask)
											
								await waitFor(() => {
									expect(result.current.todoList.length).toBe(originLength + 1)
									const newTask = {
										...mockData.newTodoTask,
										id: result.current.todoList[0]?.id
									}
									expect(result.current.todoList).toContainEqual(newTask)
								})
							})
						})
						```

						---
						## Frontend Refactor
						é€™ç‰ˆçš„é‡æ§‹æ–¹å‘æ˜¯æƒ³è¦å°‡çµæ§‹æ”¹æˆé€™æ¨£
						```
						TaskManager // æ§åˆ¶æ‰€æœ‰ List
							â””â”€ TaskList <-> todoList Model
							â””â”€ TaskList <-> finishList Model
							â””â”€ TaskList <-> archiveList Model
						```
						
						---
						## Frontend Refactor
						æª”æ¡ˆçµæ§‹
						```
						src/
						â””â”€ components/
							â””â”€ TaskManager/
								â””â”€ EditTask.tsx // ç·¨è¼¯ Task çš„å°çµ„ä»¶
								â””â”€ TaskList.tsx // å–®ç¨ä¸€å€‹ List ä½¿ç”¨çš„çµ„ä»¶ï¼Œéœ€æ”¾å…¥å°æ‡‰çš„ Model
								â””â”€ TaskManager.tsx // ç®¡ç†ä¸‰å€‹ List çš„å¤§çµ„ä»¶
						â””â”€ hooks/
							â””â”€ taskListModel/
								â””â”€ useArchiveListModel.ts // archiveList çš„ Modelï¼Œå¯å–®ç¨ä½¿ç”¨
								â””â”€ useFinishListModel.ts // finishList çš„ Modelï¼Œå¯å–®ç¨ä½¿ç”¨
								â””â”€ useTodoListModel.ts // todoList çš„ Modelï¼Œå¯å–®ç¨ä½¿ç”¨
								â””â”€ utils.ts // å…±ç”¨æ–¹æ³•
						```

						---
						## Frontend Refactor
						```javascript
						// src/types/task.ts

						// methods æ–°å¢ optionsï¼Œæä¾› Callback å‚³å…¥åŸ·è¡Œ
						export const methodOption = z.object({
							// ä¾‹å¦‚è¦é€²è¡Œæ¨‚è§€æ›´æ–°çš„æ™‚å€™
							onMutate: z.function().args(task).returns(z.void()).optional(),
							// API æˆåŠŸçš„æ™‚å€™
							onSuccess: z.function().args(task).returns(z.void()).optional(),
							// API å¤±æ•—çš„æ™‚å€™
							onError: z.function().args(errorMessage).returns(z.void()).optional(),
						})
						export type MethodOption = z.infer<typeof methodOption>
						
						export const listModel = z.object({
							userId,
							taskList,
							isLoading: z.boolean(),
							isError: z.boolean(),
							createTask: z.function().args(noHeadTask, createMethodOption.optional()).returns(z.void()).optional(),
							pushTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							finishTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							unfinishTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							archiveTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							unarchiveTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							deleteTask: z.function().args(task, methodOption.optional()).returns(z.void()).optional(),
							// å¾å¤–éƒ¨é€²è¡Œæ¨‚è§€æ›´æ–°ï¼Œå¢åŠ ä¸€å€‹ Task çš„æ–¹æ³•
							optimisticAddTask: z.function().args(task).returns(z.void()).optional(),
							// é‡æ–°ç²å–è³‡æ–™çš„æ–¹æ³•
							refetchList: z.function().args(refetchMethodOption.optional()).returns(z.void()).optional(),
						})
						
						export type ListModel = z.infer<typeof listModel>
						```

						---
						## Frontend Refactor
						ä¸€å€‹ List Model åªè² è²¬æä¾›ä¸€å€‹ List ä»¥åŠç›¸é—œéœ€è¦çš„æ–¹æ³•ã€‚

						```tsx
						// src/hooks/taskListModel/useTodoListModel.ts
						export const useTodoListModel: UseTaskListModel = ({ userId = '' } = {}) => {
							const utils = api.useContext()
							const [ taskList, setTaskList ] = useState<TaskList>([])
						
							// é‡æ–°æ•´ç†å¾Œï¼Œå°‡å°‘è¨±ä¸åŒçš„åœ°æ–¹é›†ä¸­èµ·ä¾†ï¼Œå¯ä»¥ç™¼ç¾å…¶å¯¦åªæœ‰é€™ä¸‰å€‹åœ°æ–¹ä¸åŒ
							const utilList = utils.task.todoList
							const apiList = api.task.todoList
							const filterCondition: FilterCondition = task => task.isFinished !== true && task.isArchived !== true
							
							// fetch data
							const { data: newTaskList, refetch, isLoading, isError } = apiList.useQuery({ userId })
							useLayoutEffect(() => {
								setTaskList(newTaskList || [] as TaskList)
							}, [newTaskList])
						
							// å°‡ optimistic updates çš„è™•ç†æ–¹å¼æŠ½æˆå…±ç”¨
							const createMutation = genMutation<CreateMutation>({
								userId,
								utilList: utilList,
								apiMethod: api.task.create,
								updater: createUpdater,
							})
							// é¡ä¼¼ createMutation è™•ç†
							const deleteMutation = genMutation<DeleteMutation>({...})
							const pushMutation = genMutation<PushMutation>({...})
						
							// methods æ–°å¢ options ï¼Œå¯ä»¥æä¾› Callback å‚³å…¥ï¼Œè™•ç†å…¶ä»–äº‹æƒ…
							// onMutate, onSuccess, onError
							const createTask: ListModel['createTask'] = (noHeadTask, options = {}) => {
								createMutation.mutate(noHeadTask, {
									onSuccess: (data, variables, context) => {
										options.onSuccess && options.onSuccess(data)
									},
									onError: (error, variables, context) => {
										options.onError && options.onError(error.message)
									},
								})
								options.onMutate && options.onMutate(noHeadTask)
							}
							// é¡ä¼¼ create è™•ç†å³å¯
							const deleteTask: ListModel['deleteTask'] = (task, options = {}) => {}
							const pushTask: ListModel['pushTask'] = (updatedTask, options = {}) => {}
							const finishTask: ListModel['finishTask'] = (task, options = {}) => {}
							const unfinishTask: ListModel['unfinishTask'] = (task, options = {}) => {}
							const archiveTask: ListModel['archiveTask'] = (task, options = {}) => {}
							const unarchiveTask: ListModel['unarchiveTask'] = (task, options = {}) => {}
							// é‡æ–°ç²å–è³‡æ–™çš„æ–¹æ³•
							const refetchList: ListModel['refetchList'] = (options) => {
								const run = async () => {
									await utilList.cancel()
									return await refetch()
								}
								run().then(({ data }) => {
									options && options.onSuccess && options.onSuccess(data || [])
								}).catch((error) => {
									const message = 'refetch unknown error'
									options && options.onError && options.onError(message)
								})
							}
							// æä¾›å¤–éƒ¨å¯ä»¥é€²è¡Œæ¨‚è§€æ›´æ–°ï¼Œç›´æ¥æ’å…¥è³‡æ–™
							const optimisticAddTask: ListModel['optimisticAddTask'] = (task) => {
								const newTaskList = [task, ...taskList].sort((a, b) => a.id < b.id ? 1 : -1)
								setTaskList(newTaskList)
							}
						}
						```

						---
						## Frontend Refactor
						TaskList Component å¯¦ä½œ
						```tsx
						// src/components/TaskManager/TaskList.tsx
						export const TaskList = ({
							title = '',
							model,
							// æ§åˆ¶åŠŸèƒ½æ˜¯å¦é–‹å•Ÿï¼Œä¾‹å¦‚æ˜¯å¦å¯ä»¥æ–°å¢
							activeCreate = true,
							...
							// æä¾›å¤–éƒ¨åœ¨ä¸åŒçš„æ™‚æ©ŸåŸ·è¡Œå…¶ä»–äº‹æƒ…
							onCreateMutate,
							onFinishMutate,
							...
							afterCreated,
							afterFinished,
							...
						}: TaskListProps) => {
							const { userId, taskList, createTask, pushTask, archiveTask, unarchiveTask, deleteTask, finishTask, unfinishTask } = model
							const [ newTask, setNewTask ] = useState<NoHeadTask | null>(null)
							const [ editingTask, setEditingTask ] = useState<Task | null>(null)
							
							const onCreate = () => {
								setNewTask({ title: '', userId })
							}
						
							const onSubmitCreate = (noHeadTask: NoHeadTask) => {
								const options: CreateMethodOption = {
									onMutate: noHeadTask => {
										onCreateMutate && onCreateMutate(noHeadTask)
										console.log('create onMutate')
									},
									onSuccess: task => {
										afterCreated && afterCreated(task)
										console.log('create onSuccess')
									},
									onError: error => {
										console.log('create onError')
									},
								}
								createTask && createTask(noHeadTask, options)
								setNewTask(null)
							}
							// éƒ½è·Ÿ create å·®ä¸å¤š
							const onCanselCreate = () => {}
							const onEdit = (editingTask: Task) => () => {}
							const onSubmitEdit = (updatedTask: Task) => {}
							const onCanselEdit = () => {}
							const onDelete = (task: Task) => () => {}
							const onArchive = (task: Task) => () => {}
							const onUnarchive = (task: Task) => () => {}
							const onFinish = (task: Task) => {}
							const onUnfinish = (task: Task) => {}
							const onSwichFinished = (task: Task): SpectrumCheckboxProps['onChange'] => isSelected => {
								isSelected ? onFinish(task) : onUnfinish(task)
							}
						
							return (
							<View minWidth="size-6000">
								<Header>
									<Flex justifyContent="space-between" alignItems="center">
										<Heading level={3}>{title}</Heading>
										<ButtonGroup>
											// æ˜¯å¦å•Ÿç”¨ Create Button
											<IsShow active={activeCreateAction}><ActionButton onPress={onCreate} aria-label="Add task"><AddIcon /></ActionButton></IsShow>
										</ButtonGroup>
									</Flex>
								</Header>
								<Content margin="size-200" marginBottom="size-800">
									<IsShow active={activeNewTaskComp}>
										<EditTask task={newTask} onSubmit={onSubmitCreate} onCansel={onCanselCreate} />
									</IsShow>

									{ taskList.map(task => activeEditingTaskComp(task) ?
									<EditTask key={`editing-${task.id}`} task={editingTask} onSubmit={onSubmitEdit} onCansel={onCanselEdit} /> :
									<Flex key={task.id} justifyContent="space-between">
										<Checkbox isDisabled={!activeSwitchFinishAction} marginEnd="size-200" flexGrow={1} isSelected={task.isFinished} onChange={onSwichFinished(task)}><span className={task.isFinished ? 'line-through' : ''}>{task.title}</span></Checkbox>
										<ButtonGroup>
											<IsShow active={activeEditAction}><ActionButton isQuiet onPress={onEdit(task)} aria-label="Edit task"><EditIcon /></ActionButton></IsShow>
											<IsShow active={activeArchiveAction}><ActionButton isQuiet onPress={onArchive(task)} aria-label="Archive task"><ArchiveIcon /></ActionButton></IsShow>
											<IsShow active={activeUnarchiveAction}><ActionButton isQuiet onPress={onUnarchive(task)} aria-label="Unarchive task"><ArchiveRemoveIcon /></ActionButton></IsShow>
											<IsShow active={activeDeleteAction}><ActionButton isQuiet onPress={onDelete(task)} aria-label="Delete task"><DeleteIcon /></ActionButton></IsShow>
										</ButtonGroup>
									</Flex>}
								</Content>
							</View>
							)
						}
						```

						---
						## Frontend Refactor
						TaskManager Component å¯¦ä½œ
						```tsx
						// src/components/TaskManager/TaskManager.tsx
						export const TaskManager = ({
							userId = '',
						}: TaskManagerProps) => {
							const todoListModel = useTodoListModel({ userId })
							const finishListModel = useFinishListModel({ userId })
							const archiveListModel = useArchiveListModel({ userId })
							
							// éœ€è¦çš„æ™‚å€™å¯ä»¥èª¿ç”¨ refetchList æ›´æ–°åˆ—è¡¨
							const refetchTodoList = (updatedTask: Task) => {
								const options: RefetchMethodOption = {
									onSuccess: (taskList) => {
										console.log('todo list refetch success')
									},
									onError: (error) => {
										console.log('todo list refetch error')
									}
								}
								todoListModel.refetchList && todoListModel.refetchList(options)
							}
							// éƒ½è·Ÿ refetchTodoList ä¸€æ¨£
							const refetchFinishList = (updatedTask: Task) => {}
							const refetchArchiveList = (updatedTask: Task) => {}
							// ç•¶ todo -> finish çš„æ™‚å€™ï¼Œä¸€ä½µé€²è¡Œ finishList çš„æ¨‚è§€æ›´æ–°
							const onTodoListFinishMutate = (updatedTask: Task) => {
								console.log('onTodoListFinishMutate')
								finishListModel.optimisticAddTask && finishListModel.optimisticAddTask(updatedTask)
							}
							// è·Ÿä¸Šé¢å·®ä¸å¤š
							const onTodoListArchiveMutate = (updatedTask: Task) => {}
							const onFinishListUnfinishMutate = (updatedTask: Task) => {}
							const onFinishListArchiveMutate = (updatedTask: Task) => {}
							const onArchiveListUnarchiveMutate = (updatedTask: Task) => {}
							
							// ç•¶ todo -> finishï¼Œå¾Œç«¯æ›´æ–°å®Œæˆæ™‚ï¼Œé€²è¡Œ finishList çš„ refecth
							const afterTodoListFinished = (updatedTask: Task) => {
								console.log('afterTodoListFinished')
								refetchFinishList(updatedTask)
							}
							// è·Ÿä¸Šé¢å·®ä¸å¤š
							const afterTodoListArchived = (updatedTask: Task) => {}
							const afterFinishListUnfinished = (updatedTask: Task) => {}
							const afterFinishListArchived = (updatedTask: Task) => {}
							const afterArchiveListUnarchived = (updatedTask: Task) => {}
						
							return (
							<Tabs aria-label="History of Ancient Rome">
								<TabList>
									<Item key="tasklist" textValue="Task List Tab"><TaskListIcon /><Text>Task List</Text></Item>
									<Item key="archives" textValue="Archived Tab"><ArchiveIcon /><Text>Archived</Text></Item>
								</TabList>
								<TabPanels>
									<Item key="tasklist" textValue="Task List Panel">
										<TaskList title="Today's Task"
											model={todoListModel}
											activeUnarchive={false}
											onFinishMutate={onTodoListFinishMutate}
											onArchiveMutate={onTodoListArchiveMutate}
											afterFinished={afterTodoListFinished}
											afterArchived={afterTodoListArchived}
										/>
										<TaskList title="Finished" 
											model={finishListModel}
											activeUnarchive={false}
											activeCreate={false}
											onUnfinishMutate={onFinishListUnfinishMutate}
											onArchiveMutate={onFinishListArchiveMutate}
											afterUnfinished={afterFinishListUnfinished}
											afterArchived={afterFinishListArchived}
										/>
									</Item>
									<Item key="archives" textValue="Archived Panel">
										<TaskList title="Archived"
											model={archiveListModel}
											activeArchive={false}
											activeCreate={false}
											onUnarchiveMutate={onArchiveListUnarchiveMutate}
											afterUnarchived={afterArchiveListUnarchived}
										/>
									</Item>
								</TabPanels>
							</Tabs>
							)
						}
						```

						---
						## Frontend Refactor Review
						é‚„å¯ä»¥ç¹¼çºŒä¿®æ”¹
						1. ä¸‰å€‹ List Model å¹¾ä¹é•·çš„ä¸€æ¨¡ä¸€æ¨£ï¼Œæ‡‰è©²å¯«æˆä¸€éš»ç”¨åƒæ•¸æ§åˆ¶ã€‚
						2. TaskManager éœ€è¦è‡ªè¡Œç®¡ç†ä¸‰å€‹ Model ä¹‹é–“çš„é—œä¿‚
						3. å¯ä»¥å†æœ‰ä¸€å€‹å¤§ Model è² è²¬æä¾›æ•´åˆå¾Œçš„åŠŸèƒ½
						4. ä¸¦ä¿æŒåŸæœ¬ TaskManager å°æ‡‰ä¸€å€‹ Model çš„è¨­è¨ˆ
						```
						TaskManager    <->  TaskModel
							â””â”€ TaskList  <->    â””â”€ List Model (todo)
							â””â”€ TaskList  <->    â””â”€ List Model (finish)
							â””â”€ TaskList  <->    â””â”€ List Model (archive)
						```						

						---
						## Prsentation Tool
						Slide ä½¿ç”¨ [Reveal.js](https://revealjs.com/) æº–å‚™ï¼Œå¯ä»¥ä½¿ç”¨ html çš„æ–¹å¼å»ºç«‹ç°¡å ±ï¼Œä¹Ÿæ”¯æ´ Markdownã€‚
						ä½¿ç”¨ Markdown çš„è©±ï¼Œæœƒè‡ªå‹•è½‰æ›ï¼ŒåŸºæœ¬ä¸Šåªéœ€è¦æº–å‚™å…§å®¹å³å¯ã€‚
						ä½†æœ‰å€‹å°ç¼ºé»æ˜¯ï¼Œgulp åœ¨è·‘ dev çš„æ™‚å€™æ•ˆèƒ½è¼ƒå·®ã€‚

						---
						## End
						è¬è¬æ”¶çœ‹ ğŸ‘‹

					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: 'c/t',
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
